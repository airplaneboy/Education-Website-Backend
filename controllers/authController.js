const CustomErrors = require('../errors');
const User = require('../models/User');
const RefreshToken = require('../models/RefreshToken');
const { StatusCodes } = require('http-status-codes');
const { createJwtAccessAndRefreshCookies, createRefreshAndAccessToken, verifyToken } = require('../utils/jwt');
const crypto = require('crypto');

const register = async (req, res) => {
  const { email, password, firstName, lastName, username, role } = req.body;

  if (!email || !password || !firstName || !lastName || !username)
    throw new CustomErrors.BadRequestError('Fill in all credential');

  if (await User.findOne({ email })) throw new CustomErrors.BadRequestError('This user already exist');

  const user = await User.create({ email, password, username, profile: { firstName, lastName }, role });
  const payload = { id: user._id, username: user.username, role: user.role };

  //TODO: Add a refresh token
  createJwtAccessAndRefreshCookies({ res, payload });
  res.status(StatusCodes.CREATED).json({ user });
};

const login = async (req, res) => {
  const user = req.user;

  if (!user) throw new CustomErrors.BadRequestError('User does not exist');
  //TODO: If you're building your own authentication system, it's a really good idea to include a flag in your payloads, to indicate whether that token was generated by authenticating with user credentials, or by using a refresh token. You can use this flag to authorize sensitive operations, such as changing your password or making payments - so if the user didn't log in recently, you can prompt them to log in again for sensitive operations. I would say this is a must for most applications.
  const payload = { username: user.username, userId: user._id, role: user.role };

  const refreshTokenPayload = await RefreshToken.findOne({ userId: user._id });
  const refreshToken = crypto.randomBytes(40).toString('hex');

  if (!refreshTokenPayload) {
    await RefreshToken.create({
      userId: user._id,
      refreshToken: refreshToken,
    });
    createRefreshAndAccessToken({ res, payload, refreshToken: refreshToken });
  }

  if (!refreshTokenPayload.isValid) throw new CustomErrors.BadRequestError('Invalid credentials');

  refreshTokenPayload.refreshToken = refreshToken;
  await refreshTokenPayload.save();
  createRefreshAndAccessToken({ res, payload, refreshToken: refreshToken });
};

const refreshToken = async (req, res) => {
  const { refresh_token: refreshTokenCookies } = req.signedCookies;

  const decoded = verifyToken({ token: refreshTokenCookies, secret: process.env.REFRESH_TOKEN_SECRET });
  if (!decoded) throw new CustomErrors.BadRequestError('Invalid refresh token');

  const refreshToken = await RefreshToken.findOne({
    refreshToken: decoded.refreshToken,
    userId: decoded.payload.userId,
  });

  if (!refreshToken || !refreshToken?.isValid) throw new CustomErrors.BadRequestError('Invalid refresh token');

  //TODO: can you remove the refreshToken keyword?
  createRefreshAndAccessToken({ res, payload: decoded.payload });
};

const logout = async (req, res) => {
  req.logOut((error) => {
    if (error) throw new CustomErrors.BadRequestError(`There was an error ${error}`);
  });
  res.cookie('token', '', { expires: new Date(Date.now()), httpOnly: true });
  res.redirect('/');
};

module.exports = { register, login, logout, refreshToken };
